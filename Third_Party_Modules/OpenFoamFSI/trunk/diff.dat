diff -r /Projects/IR/Users/msafdari/sourceCodes/ElmerFoamFSI/Third_Party_Modules/OpenFoamFSI/trunk/native/fsiFOAM.C native/fsiFOAM.C
5,7d4
< // my includes
< //using namespace std;
< 
18c15
<     Info << "FsiFoam:Initialize: Error: Failed to create args object." << endl;
---
>     Info << "fsifoam::Initialize::Error: Failed to create args object." << endl;
22c19
<     Info << "FsiFoam:Initialize: Error: Root case setup failed." << endl;
---
>     Info << "fsifoam::Initialize::Error: Root case setup failed." << endl;
36c33
<     Info << "FsiFoam:Initialize: Error: Failed to setup time object." << endl;
---
>     Info << "fsifoam::Initialize::Error: Failed to setup time object." << endl;
58,59c55,56
<   Info << "FsiFoam:Initialize: Create dynamic mesh for time = "
<        << runTime.timeName() << endl;
---
>   Info << "fsifoam::Initialize: Create dynamic mesh for time = "
>        << runTime.timeName() << nl << "\n";
74c71
<   Info << "FsiFoam:Initialize: Reading transportProperties" << endl;
---
>   Info << "fsifoam::Initialize: Reading transportProperties\n\n" << endl;
93c90
<   Info << "FsiFoam:CreateFluidFields: Reading field p" << endl;
---
>   Info << "Reading field p\n" << endl;
107c104
<   Info << "FsiFoam:CreateFluidFields: Reading field U" << endl;
---
>   Info << "Reading field U\n" << endl;
118c115
<   Info << "FsiFoam:CreateFluidFields: Reading/calculating face flux field phi" << endl;
---
>   Info << "Reading/calculating face flux field phi\n" << endl;
140c137
<   Info << "FsiFoam:CreateStructuresFields: Reading incremental displacement field DU" << endl;
---
>   Info << "Reading incremental displacement field DU\n" << endl;
161c158
<   Info << "FsiFoam:CreateStructuresFields: Reading incremental displacement field DV" << endl;
---
>   Info << "Reading incremental displacement field DV\n" << endl;
167c164
<   Info << "FsiFoam:CreateStructuresFields: Reading accumulated velocity field V" << endl;
---
>   Info << "Reading accumulated velocity field V\n" << endl;
174c171
<   Info << "FsiFoam:CreateStructuresFields: Reading accumulated stress field sigma" << endl;
---
>   Info << "Reading accumulated stress field sigma\n" << endl;
182c179
<   Info << "FsiFoam:CreateStructuresFields: Reading incremental stress field DSigma" << endl;
---
>   Info << "Reading incremental stress field DSigma\n" << endl;
213c210
<   Info << "FsiFoam:ReadCouplingProperties: Reading coupling properties" << endl;
---
>   Info << "\nReading coupling properties\n" << endl;
271c268
<   Info << "FsiFoam:ReadCouplingProperties:Solid patch ID: " << solidPatchID << endl;
---
>   Info << "Solid Patch ID: " << solidPatchID << endl;
364c361
<       Info << "FsiFoam:CreateInterZoneInterpolators: Create fluid-to-solid and solid-to-fluid interpolators" << endl;
---
>       Info << "Create fluid-to-solid and solid-to-fluid interpolators" << endl;
380c377
<       Info << "FsiFoam:CreateInterZoneInterpolators: Check fluid-to-solid and solid-to-fluid interpolators" << endl;
---
>       Info << "Check fluid-to-solid and solid-to-fluid interpolators" << endl;
442c439
<         Info << "FsiFoam:CreateInterZoneInterpolators: Fluid-to-solid face interpolation error: " << maxDist
---
>         Info << "Fluid-to-solid face interpolation error: " << maxDist
508c505
<         Info << "FsiFoam:CreateInterZoneInterpolators: Solid-to-fluid face interpolation error: " << maxDist
---
>         Info << "Solid-to-fluid face interpolation error: " << maxDist
659d655
<          || (couplingScheme == "NonIterative")
662c658
<           Info<< "FsiFoam:ReadFSIControl: Selecting coupling scheme " << couplingScheme << endl;
---
>           Info<< "Selecting coupling scheme " << couplingScheme << endl;
697d692
<   Info << "FsiFoam:ReadFSIControl: outerCorrTolerance = " << outerCorrTolerance << endl;
700c695
<     Info << "FsiFoam:ReadFSIControl: FSI IS ENABLED." << endl;
---
>     Info << "FSI ENABLED!!" << endl;
702c697
<     Info << "FsiFoam:ReadFSIControl: FSI IS DISABLED." << endl;
---
>     Info << "FSI DISABLED!!!" << endl;
753,756d747
<   // Masoud:
<   Info << "accumulatedFluidInterfaceDisplacement = " << endl;
<   Info << accumulatedFluidInterfaceDisplacement << endl;
<   // Masoud: End
973,975d963
<               // Masoud
<               Info << "Moving only interface points..." << endl;
<               // Masoud: End
1004,1006d991
<               // Masoud
<               Info << "Moving the whole mesh .... " << endl;
<               // Masoud: End
1596,1602d1580
< 
<           // Masoud
<           Info << "solidPatchPointsDispl = " << endl;
<           Info << solidPatchPointsDispl << endl;
<           Info << "fluidPatchPointsDispl = " << endl;
<           Info << fluidPatchPointsDispl << endl;
<           // Masoud : End
1879,1882d1856
<   // Masoud : Checking AccumulatedFluidInterfaceDisplacement
<   Info << "Checking AccumulatedFluidInterfaceDisplacementi = " << endl;
<   Info << accumulatedFluidInterfaceDisplacement;
<   // Masoud: End
1948d1921
<         Info << "outerCorr = " << outerCorr << endl;
2033,2035d2005
<               // Masoud
<               Info << "Moving only interface...";
<               // Masoud : End
2065,2067d2034
<               // Masoud
<               Info << "Moving the whole mesh...";
<               // Masoud: End
2200,2202d2166
<         // Masoud
<         Info << "Performing " << nCorrPISO << " Pressure corrections." << endl;
<         // Masoud End
2221,2223d2184
< 
<                 // Added by Masoud
<                 //Info << "p = " << (this-> p()) << endl;
2258,2281c2219,2220
<             // Original: a fixed displacement delta will be used for the solid
<             //this->UpdateFSISurface(solidPatchPointsDispl);
<             // Oridinal : End
<             
<             // Masoud : in the initial step displacement delta will be added
<             //          and for the rest of the process, it will be consider-
<             //          as zeros vector.
<             if (outerCorr == 1)
<               {
<                 this->UpdateFSISurface(solidPatchPointsDispl);
<               } else {
<                   solidPatchPointsDispl = vector::zero;
<                   //fluidPatchPointsDispl = vector::zero;
<               }
<             // Masoud : End
<             
<  	    // Masoud
<             Info << "solidPatchPointsDispl = " << solidPatchPointsDispl << endl;
<             //Masoud end
<             
<             // Original (solidPatchPointsDispl won't change by iteration
<             // therefore huge pressure build-up happens) 
<             fsiResidual = (solidPatchPointsDispl - fluidPatchPointsDispl);                          
<             // Original end
---
>                           
>             this->UpdateFSISurface(solidPatchPointsDispl);
2282a2222
>             fsiResidual = solidPatchPointsDispl - fluidPatchPointsDispl;                          
2300c2240
<        && (outerCorr < nOuterCorr)  //Masoud changed from outerCorr < nOuterCorr
---
>        && (outerCorr < nOuterCorr)
2312,2315c2252
< // Masoud: This is simple iteration-less scheme
< int fsifoam_module::StepFluidNonItr(){
< 
<   Foam::argList &args(this->ArgList());
---
> int fsifoam_module::Dump(){
2317,2323c2254,2267
<   dynamicFvMesh &fluidsMesh(this->FluidMesh());
<   //  IOdictionary &transportProperties(this->TransportProperties());
<   dimensionedScalar &nu(this->nu());
<   dimensionedScalar &rhoFluid(this->rhoFluid());
<   volScalarField &p(this->p());
<   volVectorField &U(this->U());
<   surfaceScalarField &phi(this->phi());
---
>   fvMesh &structuresMesh(this->StructuresMesh());
>   volSymmTensorField &sigma(this->sigma());
>   volScalarField sigmaEq
>     (
>      IOobject
>      (
>       "sigmaEq",
>       runTime.timeName(),
>       structuresMesh,
>       IOobject::NO_READ,
>       IOobject::AUTO_WRITE
>       ),
>      sqrt((3.0/2.0)*magSqr(dev(sigma)))
>      );
2324a2269,2270
>   Info<< "Max sigmaEq = " << max(sigmaEq).value()
>       << endl;
2326c2272,2274
<   // //  IOdictionary &couplingProperties(this->CouplingProperties());
---
>   runTime.write();
>   return 0;
> };
2328,2397c2276,2283
<   label fluidPatchID(this->FluidPatchID());
<   label fluidZoneID(this->FluidZoneID());
<   label solidZoneID(this->SolidZoneID());
<     
<   bool feMotionSolver(this->FEMotion());
<   bool fvMotionSolver(this->FVMotion());
<   vectorField &accumulatedFluidInterfaceDisplacement(this->AccumulatedFluidInterfaceDisplacements());
<   //Info << "Checking AccumulatedFluidInterfaceDisplacementi = " << endl;
<   //Info << accumulatedFluidInterfaceDisplacement;
<   solidTractionFvPatchVectorField &tForce(this->tForce());
<     
<   zoneToZoneInterpolation &interpolatorFluidSolid(this->interpFluidSolid());
<   zoneToZoneInterpolation &interpolatorSolidFluid(this->interpSolidFluid());
<     
<   scalar &sumLocalContErr(this->LocalContErr());
<   scalar &globalContErr(this->GlobalContErr());
<   scalar &cumulativeContErr(this->CumulativeContErr());
<     
<   labelList &globalFaceZones(this->GlobalFaceZones());
<   labelListList &globalToLocalFaceZonePointMap(this->GlobalToLocalFaceZonePointMap());
<   runTime++;
<   if(!runTime.end()){
<       
<     this->ReadPISOControls();
<     this->ReadFSIControls();
<     word couplingScheme(this->CouplingScheme());
<     //        label &outerCorr(this->OuterCorr());
<     scalar &fsiRelaxationFactor(this->FSIRelaxationFactor());
<     //        scalar &fsiRelaxationFactorMin(this->FSIRelaxationFactorMin());
<     Switch fsi(this->FSIEnabled());
<     int &nCorrPISO(this->NCorrPISO());
<     int &nNonOrthCorr(this->NNonOrthCorr());
<     scalar &interfaceDeformationLimit(this->InterfaceDeformationLimit());
<     scalar &outerCorrTolerance(this->OuterCorrTolerance());
<     int &nOuterCorr(this->NOuterCorr());
<       
<     vectorField fluidPatchPointsDispl
<       (
<        fluidsMesh.boundaryMesh()[fluidPatchID].nPoints(),
<        vector::zero
<        );
<         
<     vectorField fluidPatchPointsDisplOld
<       (
<        fluidsMesh.boundaryMesh()[fluidPatchID].nPoints(),
<        vector::zero
<        );
<         
<     vectorField solidPatchPointsDispl
<       (
<        fluidsMesh.boundaryMesh()[fluidPatchID].nPoints(),
<        vector::zero
<        );
<         
<     vectorField fsiResidual
<       (
<        fluidsMesh.boundaryMesh()[fluidPatchID].nPoints(),
<        vector::zero
<        );
<         
<     vectorField fsiResidualOld
<       (
<        fluidsMesh.boundaryMesh()[fluidPatchID].nPoints(),
<        vector::zero
<        );
<         
<         
<     scalar initialFsiResidualNorm = 0;
<     scalar fsiResidualNorm = 0;        
<     label outerCorr=0;
---
> ///
> /// @brief "Loads" IcoFoamModule
> ///
> ///
> //static void fsifoam_module::Load(const std::string &name){
> void fsifoam_module::Load(const std::string &name){
>   std::cout << "Loading FsiFoamModule with name " << name 
>             << "." << std::endl;
2399,3150c2285,2291
<     do
<       {
<         outerCorr++;
<         Info << "FsiFoam:StepFluidNonItr: outerCorr = " << outerCorr << endl;
<         
<         //#           include "setInterfaceDisplacement.H"
<         Info << "FsiFoam:StepFluidNonItr: Time = " << runTime.timeName()
<              << ", iteration: " << outerCorr << endl;
<         // Updating fluid patch displacement        
<         this->UpdateFSISurface(fluidPatchPointsDispl);
<         //Info << " Updating fluid interface coordinates with : " << endl;
<         //Info << fluidPatchPointsDispl << endl;
<         {
< 
<           const vectorField& n =
<             fluidsMesh.boundaryMesh()[fluidPatchID].pointNormals();
<                   
<           primitivePatchInterpolation patchInterpolator
<             (
<              fluidsMesh.boundaryMesh()[fluidPatchID]
<              );
<                   
<           scalarField pointDeltaCoeffs =
<             patchInterpolator.faceToPointInterpolate
<             (
<              fluidsMesh.boundary()[fluidPatchID].deltaCoeffs()
<              );
<                   
<           scalar delta =
<             gMax
<             (
<              mag
<              (
<               n
<               & (
<                  accumulatedFluidInterfaceDisplacement
<                  + fluidPatchPointsDispl
<                  )
<               )
<              *pointDeltaCoeffs
<              );
<                   
<           Info << "FsiFoam:StepFluidNonItr: Maximal accumulated displacement of interface points: "
<                << delta << endl;
<                   
<           if(delta < interfaceDeformationLimit)
<             {
<               // Move only interface points
<               Info << "FsiFoam:StepFluidNonItr: Moving only interface...";
<               pointField newPoints = fluidsMesh.allPoints();
<                       
<               const labelList& meshPoints =
<                 fluidsMesh.boundaryMesh()[fluidPatchID].meshPoints();
<                       
<               forAll (fluidPatchPointsDispl, pointI)
<                 {
<                   //Info << "1. meshPoints[" << pointI << "] = " << meshPoints[pointI]
<                        //<< endl;
< 
<                   newPoints[meshPoints[pointI]] +=
<                     fluidPatchPointsDispl[pointI];
<                 }
<                       
<               twoDPointCorrector twoDCorrector(fluidsMesh);
<                       
<               twoDCorrector.correctPoints(newPoints);
<                       
<               fluidsMesh.movePoints(newPoints);
<                       
<               // Accumulate interface points displacement
<               accumulatedFluidInterfaceDisplacement +=
<                 fluidPatchPointsDispl;
<             }
<           else
<             {
<               // Move whole fluid mesh
<               Info << "FsiFoam:StepFluidNonItr: Moving the whole mesh...";
<               pointField newPoints = fluidsMesh.allPoints();
<                       
<               const labelList& meshPoints =
<                 fluidsMesh.boundaryMesh()[fluidPatchID].meshPoints();
<                       
<               forAll (accumulatedFluidInterfaceDisplacement, pointI)
<                 {
<                   //Info << "2. meshPoints[" << pointI << "] = " << meshPoints[pointI]
<                        //<< endl;
<                   newPoints[meshPoints[pointI]] -=
<                     accumulatedFluidInterfaceDisplacement[pointI];
<                 }
<                       
<               twoDPointCorrector twoDCorrector(fluidsMesh);
<                       
<               twoDCorrector.correctPoints(newPoints);
<                       
<               fluidsMesh.movePoints(newPoints);
<                       
<               accumulatedFluidInterfaceDisplacement +=
<                 fluidPatchPointsDispl;
<                       
<               if (feMotionSolver)
<                 {
<                   tetPointVectorField& motionU =
<                     const_cast<tetPointVectorField&>
<                     (
<                      fluidsMesh.objectRegistry::
<                      lookupObject<tetPointVectorField>
<                      (
<                       "motionU"
<                       )
<                      );
<                           
<                   fixedValueTetPolyPatchVectorField& motionUFluidPatch =
<                     refCast<fixedValueTetPolyPatchVectorField>
<                     (
<                      motionU.boundaryField()[fluidPatchID]
<                      );
<                           
<                   tetPolyPatchInterpolation tppi
<                     (
<                      refCast<const faceTetPolyPatch>(motionUFluidPatch.patch())
<                      );
<                           
<                   motionUFluidPatch ==
<                     tppi.pointToPointInterpolate
<                     (
<                      accumulatedFluidInterfaceDisplacement
<                      /runTime.deltaT().value()
<                      );
<                 }
<               else if (fvMotionSolver)
<                 {
<                   pointVectorField& motionU =
<                     const_cast<pointVectorField&>
<                     (
<                      fluidsMesh.objectRegistry::
<                      lookupObject<pointVectorField>
<                      (
<                       "pointMotionU"
<                       )
<                      );
<                 
<                   fixedValuePointPatchVectorField& motionUFluidPatch =
<                     refCast<fixedValuePointPatchVectorField>
<                     (
<                      motionU.boundaryField()[fluidPatchID]
<                      );
<                 
<                   motionUFluidPatch ==
<                     accumulatedFluidInterfaceDisplacement
<                     /runTime.deltaT().value();
<                 }
<               else
<                 {
<                   FatalErrorIn(args.executable())
<                     << "FsiFoam:StepFluidNonItr: Problem with mesh motion solver selection"
<                     << abort(FatalError);
<                 }
<               
< 
<               Info << "FsiFoam:StepFluidNonItr: runTime.deltaT()  = "
<               << runTime.deltaT().value() << endl;
< 
<     
<               fluidsMesh.update();
<                       
<               accumulatedFluidInterfaceDisplacement = vector::zero;
<             }
<         }
<                 
<         if(fluidsMesh.moving())
<           {
<             // Make the fluxes relative
<             Info << "Compensating for mesh movment !" << endl;
<             phi -= fvc::meshPhi(U);
<           }
<                   
< 
<         scalar CoNum = 0.0;
<         scalar meanCoNum = 0.0;
<         scalar velMag = 0.0;
<                     
<         if (fluidsMesh.nInternalFaces())
<           {
<             surfaceScalarField magPhi = mag(phi);
<                         
<             surfaceScalarField SfUfbyDelta =
<               fluidsMesh.surfaceInterpolation::deltaCoeffs()*magPhi;
<                         
<             const scalar deltaT = runTime.deltaT().value();
<                         
<             CoNum = max(SfUfbyDelta/fluidsMesh.magSf()).value()*deltaT;
<                         
<             meanCoNum = (sum(SfUfbyDelta)/sum(fluidsMesh.magSf())).value()*deltaT;
<                         
<             velMag = max(magPhi/fluidsMesh.magSf()).value();
<           }
<                     
<         Info<< "FsiFoam:StepFluidNonItr: Courant Number mean: " << meanCoNum
<             << " max: " << CoNum
<             << " velocity magnitude: " << velMag
<             << endl;
<                     
<         fvVectorMatrix UEqn
<           (
<            fvm::ddt(U)
<            + fvm::div(phi, U)
<            - fvm::laplacian(nu, U)
<            );
<                   
<         solve(UEqn == -fvc::grad(p));
<                   
<         // --- PISO loop
<         volScalarField rUA = 1.0/UEqn.A();
<         //Info << "nCorrPISO = " << nCorrPISO << endl;
<         //Info << "nNonOrthCorr = " << nNonOrthCorr << endl;
<         for (int corr=0; corr<nCorrPISO; corr++)
<           {
<             U = rUA*UEqn.H();
<             phi = (fvc::interpolate(U) & fluidsMesh.Sf());
<                       
<             adjustPhi(phi, U, p);
<                       
<             for (int nonOrth=0; nonOrth<=nNonOrthCorr; nonOrth++)
<               {
<                 fvScalarMatrix pEqn
<                   (
<                    fvm::laplacian(rUA, p)
<                    == fvc::div(phi)
<                    );
<                           
<                 pEqn.setReference(pRefCell, pRefValue);
<                 pEqn.solve();
< 
<                 //Info << "p = " << p << endl;
<                           
<                 if (nonOrth == nNonOrthCorr)
<                   {
<                     phi -= pEqn.flux();
<                   }
<               }
<                       
<             {
<               volScalarField contErr = fvc::div(phi);
<                         
<               sumLocalContErr = runTime.deltaT().value()*
<                 mag(contErr)().weightedAverage(fluidsMesh.V()).value();
<                         
<               globalContErr = runTime.deltaT().value()*
<                 contErr.weightedAverage(fluidsMesh.V()).value();
<                         
<               cumulativeContErr += globalContErr;
<                         
<               Info<< "FsiFoam:StepFluidNonItr: time step continuity errors : sum local = " << sumLocalContErr
<                   << ", global = " << globalContErr
<                   << ", cumulative = " << cumulativeContErr
<                   << endl;
<             }
<                       
<             U -= rUA*fvc::grad(p);
<             U.correctBoundaryConditions();
<           }
<                
<       }
<     while
<       ( outerCorr < 1 );
<     
<     
<     if (runTime.outputTime())
<       {
<         runTime.write();
<       }
<   }
<   return(0);  
< }
< //Masoud End (StepFluidNonItr)
< 
< 
< //Masoud: StepFluidItr
< int fsifoam_module::StepFluidItr(){
< 
<   Foam::argList &args(this->ArgList());
<   Foam::Time &runTime(this->RunTime());
<   dynamicFvMesh &fluidsMesh(this->FluidMesh());
<   //  IOdictionary &transportProperties(this->TransportProperties());
<   dimensionedScalar &nu(this->nu());
<   dimensionedScalar &rhoFluid(this->rhoFluid());
<   volScalarField &p(this->p());
<   volVectorField &U(this->U());
<   surfaceScalarField &phi(this->phi());
<     
<     
<   // //  IOdictionary &couplingProperties(this->CouplingProperties());
< 
<   label fluidPatchID(this->FluidPatchID());
<   label fluidZoneID(this->FluidZoneID());
<   label solidZoneID(this->SolidZoneID());
<     
<   bool feMotionSolver(this->FEMotion());
<   bool fvMotionSolver(this->FVMotion());
<   vectorField &accumulatedFluidInterfaceDisplacement(this->AccumulatedFluidInterfaceDisplacements());
<   // Masoud : Checking AccumulatedFluidInterfaceDisplacement
<   Info << "Checking AccumulatedFluidInterfaceDisplacementi = " << endl;
<   Info << accumulatedFluidInterfaceDisplacement;
<   // Masoud: End
<   solidTractionFvPatchVectorField &tForce(this->tForce());
<     
<   zoneToZoneInterpolation &interpolatorFluidSolid(this->interpFluidSolid());
<   zoneToZoneInterpolation &interpolatorSolidFluid(this->interpSolidFluid());
<     
<   scalar &sumLocalContErr(this->LocalContErr());
<   scalar &globalContErr(this->GlobalContErr());
<   scalar &cumulativeContErr(this->CumulativeContErr());
<     
<   labelList &globalFaceZones(this->GlobalFaceZones());
<   labelListList &globalToLocalFaceZonePointMap(this->GlobalToLocalFaceZonePointMap());
<   runTime++;
<   if(!runTime.end()){
<       
<     this->ReadPISOControls();
<     this->ReadFSIControls();
<     word couplingScheme(this->CouplingScheme());
<     //        label &outerCorr(this->OuterCorr());
<     scalar &fsiRelaxationFactor(this->FSIRelaxationFactor());
<     //        scalar &fsiRelaxationFactorMin(this->FSIRelaxationFactorMin());
<     Switch fsi(this->FSIEnabled());
<     int &nCorrPISO(this->NCorrPISO());
<     int &nNonOrthCorr(this->NNonOrthCorr());
<     scalar &interfaceDeformationLimit(this->InterfaceDeformationLimit());
<     scalar &outerCorrTolerance(this->OuterCorrTolerance());
<     int &nOuterCorr(this->NOuterCorr());
<       
<     vectorField fluidPatchPointsDispl
<       (
<        fluidsMesh.boundaryMesh()[fluidPatchID].nPoints(),
<        vector::zero
<        );
<         
<     vectorField fluidPatchPointsDisplOld
<       (
<        fluidsMesh.boundaryMesh()[fluidPatchID].nPoints(),
<        vector::zero
<        );
<         
<     vectorField solidPatchPointsDispl
<       (
<        fluidsMesh.boundaryMesh()[fluidPatchID].nPoints(),
<        vector::zero
<        );
<         
<     vectorField fsiResidual
<       (
<        fluidsMesh.boundaryMesh()[fluidPatchID].nPoints(),
<        vector::zero
<        );
<         
<     vectorField fsiResidualOld
<       (
<        fluidsMesh.boundaryMesh()[fluidPatchID].nPoints(),
<        vector::zero
<        );
<         
<         
<     scalar initialFsiResidualNorm = 0;
<     scalar fsiResidualNorm = 0;        
<     label outerCorr=0;
< 
<     do
<       {
<         outerCorr++;
<         Info << "outerCorr = " << outerCorr << endl;
<         
<         //#           include "setInterfaceDisplacement.H"
<         Info << "\nTime = " << runTime.timeName()
<              << ", iteration: " << outerCorr << endl;
<         
<         if (outerCorr < 3 || couplingScheme == "FixedRelaxation")
<           {
<             Info << "Current fsi under-relaxation factor: "
<                  << fsiRelaxationFactor << endl;
<             
<             fluidPatchPointsDisplOld = fluidPatchPointsDispl;
<                   
<             fluidPatchPointsDispl += fsiRelaxationFactor*fsiResidual;
<           }
<         else
<           {
<             if (couplingScheme == "Aitken")
<               {
<                 fsiRelaxationFactor =
<                   -fsiRelaxationFactor
<                   *(
<                     gSum
<                     (
<                      fsiResidualOld
<                      &(fsiResidual - fsiResidualOld)
<                      )
<                     /(
<                       gSum
<                       (
<                        (fsiResidual - fsiResidualOld)
<                        &(fsiResidual - fsiResidualOld)
<                        )
<                       )
<                     );
<                       
<                 fsiRelaxationFactor = mag(fsiRelaxationFactor);
<                       
<                 Info << "Current fsi under-relaxation factor (Aitken): "
<                      << fsiRelaxationFactor << endl;
<                       
<                 fluidPatchPointsDisplOld = fluidPatchPointsDispl;
<                       
<                 fluidPatchPointsDispl +=
<                   fsiRelaxationFactor*fsiResidual;
<               }
<           }
<               
<         {
< 
<           const vectorField& n =
<             fluidsMesh.boundaryMesh()[fluidPatchID].pointNormals();
<                   
<           primitivePatchInterpolation patchInterpolator
<             (
<              fluidsMesh.boundaryMesh()[fluidPatchID]
<              );
<                   
<           scalarField pointDeltaCoeffs =
<             patchInterpolator.faceToPointInterpolate
<             (
<              fluidsMesh.boundary()[fluidPatchID].deltaCoeffs()
<              );
<                   
<           scalar delta =
<             gMax
<             (
<              mag
<              (
<               n
<               & (
<                  accumulatedFluidInterfaceDisplacement
<                  + fluidPatchPointsDispl
<                  - fluidPatchPointsDisplOld
<                  )
<               )
<              *pointDeltaCoeffs
<              );
<                   
<           Info << "Maximal accumulated displacement of interface points: "
<                << delta << endl;
<                   
<           if(delta < interfaceDeformationLimit)
<             {
<               // Move only interface points
<               // Masoud
<               Info << "Moving only interface...";
<               // Masoud : End
<               pointField newPoints = fluidsMesh.allPoints();
<                       
<               const labelList& meshPoints =
<                 fluidsMesh.boundaryMesh()[fluidPatchID].meshPoints();
<                       
<               forAll (fluidPatchPointsDispl, pointI)
<                 {
<                   //Info << "1. meshPoints[" << pointI << "] = " << meshPoints[pointI]
<                        //<< endl;
< 
<                   newPoints[meshPoints[pointI]] +=
<                     fluidPatchPointsDispl[pointI]
<                     - fluidPatchPointsDisplOld[pointI];
<                 }
<                       
<               twoDPointCorrector twoDCorrector(fluidsMesh);
<                       
<               twoDCorrector.correctPoints(newPoints);
<                       
<               fluidsMesh.movePoints(newPoints);
<                       
<               // Accumulate interface points displacement
<               accumulatedFluidInterfaceDisplacement +=
<                 fluidPatchPointsDispl
<                 - fluidPatchPointsDisplOld;
<             }
<           else
<             {
<               // Move whole fluid mesh
<               // Masoud
<               Info << "Moving the whole mesh...";
<               // Masoud: End
<               pointField newPoints = fluidsMesh.allPoints();
<                       
<               const labelList& meshPoints =
<                 fluidsMesh.boundaryMesh()[fluidPatchID].meshPoints();
<                       
<               forAll (accumulatedFluidInterfaceDisplacement, pointI)
<                 {
<                   //Info << "2. meshPoints[" << pointI << "] = " << meshPoints[pointI]
<                        //<< endl;
<                   newPoints[meshPoints[pointI]] -=
<                     accumulatedFluidInterfaceDisplacement[pointI];
<                 }
<                       
<               twoDPointCorrector twoDCorrector(fluidsMesh);
<                       
<               twoDCorrector.correctPoints(newPoints);
<                       
<               fluidsMesh.movePoints(newPoints);
<                       
<               accumulatedFluidInterfaceDisplacement +=
<                 fluidPatchPointsDispl
<                 - fluidPatchPointsDisplOld;
<                       
<                       
<               if (feMotionSolver)
<                 {
<                   tetPointVectorField& motionU =
<                     const_cast<tetPointVectorField&>
<                     (
<                      fluidsMesh.objectRegistry::
<                      lookupObject<tetPointVectorField>
<                      (
<                       "motionU"
<                       )
<                      );
<                           
<                   fixedValueTetPolyPatchVectorField& motionUFluidPatch =
<                     refCast<fixedValueTetPolyPatchVectorField>
<                     (
<                      motionU.boundaryField()[fluidPatchID]
<                      );
<                           
<                   tetPolyPatchInterpolation tppi
<                     (
<                      refCast<const faceTetPolyPatch>(motionUFluidPatch.patch())
<                      );
<                           
<                   motionUFluidPatch ==
<                     tppi.pointToPointInterpolate
<                     (
<                      accumulatedFluidInterfaceDisplacement
<                      /runTime.deltaT().value()
<                      );
<                 }
<               else if (fvMotionSolver)
<                 {
<                   pointVectorField& motionU =
<                     const_cast<pointVectorField&>
<                     (
<                      fluidsMesh.objectRegistry::
<                      lookupObject<pointVectorField>
<                      (
<                       "pointMotionU"
<                       )
<                      );
<                 
<                   fixedValuePointPatchVectorField& motionUFluidPatch =
<                     refCast<fixedValuePointPatchVectorField>
<                     (
<                      motionU.boundaryField()[fluidPatchID]
<                      );
<                 
<                   motionUFluidPatch ==
<                     accumulatedFluidInterfaceDisplacement
<                     /runTime.deltaT().value();
<                 }
<               else
<                 {
<                   FatalErrorIn(args.executable())
<                     << "Problem with mesh motion solver selection"
<                     << abort(FatalError);
<                 }
<                       
<               fluidsMesh.update();
<                       
<               accumulatedFluidInterfaceDisplacement = vector::zero;
<             }
<         }
<                 
<         if(fluidsMesh.moving())
<           {
<             // Make the fluxes relative
<             phi -= fvc::meshPhi(U);
<           }
<                   
< 
<         scalar CoNum = 0.0;
<         scalar meanCoNum = 0.0;
<         scalar velMag = 0.0;
<                     
<         if (fluidsMesh.nInternalFaces())
<           {
<             surfaceScalarField magPhi = mag(phi);
<                         
<             surfaceScalarField SfUfbyDelta =
<               fluidsMesh.surfaceInterpolation::deltaCoeffs()*magPhi;
<                         
<             const scalar deltaT = runTime.deltaT().value();
<                         
<             CoNum = max(SfUfbyDelta/fluidsMesh.magSf()).value()*deltaT;
<                         
<             meanCoNum = (sum(SfUfbyDelta)/sum(fluidsMesh.magSf())).value()*deltaT;
<                         
<             velMag = max(magPhi/fluidsMesh.magSf()).value();
<           }
<                     
<         Info<< "Courant Number mean: " << meanCoNum
<             << " max: " << CoNum
<             << " velocity magnitude: " << velMag
<             << endl;
<                     
<         fvVectorMatrix UEqn
<           (
<            fvm::ddt(U)
<            + fvm::div(phi, U)
<            - fvm::laplacian(nu, U)
<            );
<                   
<         solve(UEqn == -fvc::grad(p));
<                   
<         // --- PISO loop
<         volScalarField rUA = 1.0/UEqn.A();
<         // Masoud
<         Info << "Performing " << nCorrPISO << " Pressure corrections." << endl;
<         // Masoud End
<                   
<         for (int corr=0; corr<nCorrPISO; corr++)
<           {
<             U = rUA*UEqn.H();
<             phi = (fvc::interpolate(U) & fluidsMesh.Sf());
<                       
<             adjustPhi(phi, U, p);
<                       
<             for (int nonOrth=0; nonOrth<=nNonOrthCorr; nonOrth++)
<               {
<                 fvScalarMatrix pEqn
<                   (
<                    fvm::laplacian(rUA, p)
<                    == fvc::div(phi)
<                    );
<                           
<                 pEqn.setReference(pRefCell, pRefValue);
<                 pEqn.solve();
< 
<                 // Added by Masoud
<                 //Info << "p = " << (this-> p()) << endl;
<                           
<                 if (nonOrth == nNonOrthCorr)
<                   {
<                     phi -= pEqn.flux();
<                   }
<               }
<                       
<             {
<               volScalarField contErr = fvc::div(phi);
<                         
<               sumLocalContErr = runTime.deltaT().value()*
<                 mag(contErr)().weightedAverage(fluidsMesh.V()).value();
<                         
<               globalContErr = runTime.deltaT().value()*
<                 contErr.weightedAverage(fluidsMesh.V()).value();
<                         
<               cumulativeContErr += globalContErr;
<                         
<               Info<< "time step continuity errors : sum local = " << sumLocalContErr
<                   << ", global = " << globalContErr
<                   << ", cumulative = " << cumulativeContErr
<                   << endl;
<             }
<                       
<             U -= rUA*fvc::grad(p);
<             U.correctBoundaryConditions();
<           }
<                
<         {
<           Info << "Setting tractionis on solid patch" << endl;
<                       
<           {
<                            
<             fsiResidualOld = fsiResidual;
<             this->UpdateFSISurface(solidPatchPointsDispl);
<             Info << "solidPatchPointsDispl = " << solidPatchPointsDispl << endl;
<             
<             fsiResidual = (solidPatchPointsDispl - fluidPatchPointsDispl);                          
<             fsiResidualNorm = ::sqrt(gSum(magSqr(fsiResidual)));
<                           
<             if (outerCorr == 1)
<               {
<                 initialFsiResidualNorm = fsiResidualNorm;
<               }
<                           
<             fsiResidualNorm /= initialFsiResidualNorm + SMALL;
<                           
<             Info << "Current fsi residual norm: " << fsiResidualNorm << endl;
<           }
<         }
<       }
<     while
<       (
<        (fsiResidualNorm > outerCorrTolerance)
<        && (outerCorr < nOuterCorr)  //Masoud changed from outerCorr < nOuterCorr
<        );
<     
<     
<     if (runTime.outputTime())
<       {
<         runTime.write();
<       }
<   }
<   return(0);  
< }
< //Masoud End StepFluidItr
< 
< int fsifoam_module::Dump(){
<   Foam::Time &runTime(this->RunTime());
<   fvMesh &structuresMesh(this->StructuresMesh());
<   volSymmTensorField &sigma(this->sigma());
<   volScalarField sigmaEq
<     (
<      IOobject
<      (
<       "sigmaEq",
<       runTime.timeName(),
<       structuresMesh,
<       IOobject::NO_READ,
<       IOobject::AUTO_WRITE
<       ),
<      sqrt((3.0/2.0)*magSqr(dev(sigma)))
<      );
<     
<   Info<< "Max sigmaEq = " << max(sigmaEq).value()
<       << endl;
<     
<   runTime.write();
<   return 0;
< };
< 
< ///
< /// @brief "Loads" IcoFoamModule
< ///
< ///
< //static void fsifoam_module::Load(const std::string &name){
< void fsifoam_module::Load(const std::string &name){
<   std::cout << "Loading FsiFoamModule with name " << name 
<             << "." << std::endl;
< 
<   /// Register module with COM
<   fsifoam_module *module_pointer = new fsifoam_module();
<   COM_new_window(name, MPI_COMM_NULL);
<   module_pointer->my_window_name = name;
<   std::string global_name(name+".global");
<   COM_new_dataitem(global_name.c_str(),'w',COM_VOID,1,"");
<   COM_set_object(global_name.c_str(),0,module_pointer);
---
>   /// Register module with COM
>   fsifoam_module *module_pointer = new fsifoam_module();
>   COM_new_window(name, MPI_COMM_NULL);
>   module_pointer->my_window_name = name;
>   std::string global_name(name+".global");
>   COM_new_dataitem(global_name.c_str(),'w',COM_VOID,1,"");
>   COM_set_object(global_name.c_str(),0,module_pointer);
3276a2418
>   Info << "This is added by Masoud" << endl;
3317,3332d2458
<     //Masoud
<     UpdateFSISurfaceMesh();
<     //Masoud : End
< 
<     // Masoud : cheking impact data
<     Info << "numPointSurface = " << numPointsSurface << endl;
<     Info << "numElementSurface = " << numElementsSurface << endl;
<     Info << "SurfaceCoordinates = " << endl;
<     for (int i = 0; i < numPointsSurface; i++)
<     {
< 	Info << surfaceCoordinates[i*3] << " "
<              << surfaceCoordinates[i*3+1] << " "
<              << surfaceCoordinates[i*3+2] << endl;
<     }
< 
<     // Masoud : end
3346,3350d2471
<   // Masoud: probe output file and preps
<   ofstream prb2DmpFile;
<   dynamicFvMesh &fluidsMesh(this->FluidMesh());
<   pointField foamCoords = fluidsMesh.allPoints();
<   // Masoud: end
3354c2475
<   Info << "FsiFoam:StepFluid: Stepping fluid solver..." << endl;
---
>   Info << "\nStepping time loop\n" << endl;
3358,3371c2479,2481
<     Info << "FsiFoam:StepFluid: Time = " << runTime.timeName() << endl;
<     // Original: This step routine does perform iterations properly
<     //  StepFluidAlone();
<     // Original: End
<     
<     // Masoud: Non-iterative stepping
<      StepFluidNonItr();
<     // Masoud: end
< 
<     // Masoud: Iterative stepping
<     //StepFluidItr();
<     // Masoud: end
<     
<     Info<< "FsiFoam:StepFluid: ExecutionTime = " << runTime.elapsedCpuTime() << " s"
---
>     Info << "Time = " << runTime.timeName() << nl << endl;
>     StepFluidAlone();
>     Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
3373c2483
<         << endl;
---
>         << endl << endl;
3379,3402c2489,2490
<     UpdateFSISurfaceData(); // Masoud: updates tractions and pressures
<     UpdateFSISurfaceMesh(); // Masoud: updates surface mesh
< 
<     // Masoud : cheking impact data
<     //Info << "numPointSurface = " << numPointsSurface << endl;
<     //Info << "numElementSurface = " << numElementsSurface << endl;
<     //Info << "SurfaceCoordinates = " << endl;
<     //for (int i = 0; i < numPointsSurface; i++)
<     //{
<     //	Info << surfaceCoordinates[i*3] << " "
<     //         << surfaceCoordinates[i*3+1] << " "
<     //         << surfaceCoordinates[i*3+2] << endl;
<     //}
<     // Masoud : end
< 
<     // Masoud: output for probe
<     prb2DmpFile.open("prb2.dat", std::ios::app);
<     prb2DmpFile <<  runTime.timeName()  << " " << \
<     foamCoords[64].x() << " " << \
<     foamCoords[64].y() << " " << \
<     foamCoords[64].z() << "\n"; 
<     prb2DmpFile.close();
<     // Masoud: end
< 
---
>     UpdateFSISurfaceData();
>     UpdateFSISurfaceMesh();
3405c2493
<     Info<< "FsiFoam:StepFluid: End\n" << endl;
---
>     Info<< "End\n" << endl;
3474c2562
<    
---
> 
3490,3494d2577
<   //Masoud : Testing displacement
<   std::cout << 
<   "FsiFoam:UpdateFSISurface: Reporting solid displacements to the fluid solver" << std::endl;
<   //std::cout<< "Displacements passed to me : " << std::endl;
<   // Masoud : End
3505,3509d2587
<     //Masoud : Testing displacement
<     //std::cout<< solidDisplacement[3*i] << " " 
<     //         << solidDisplacement[3*i+1] << " "
<     //         << solidDisplacement[3*i+2] << std::endl;
<     //Masoud: End
3516,3519d2593
<    //Masoud
<    double currTime((this->RunTime()).value());
<    Info << "FsiFoam:UpdateFSISurface: Reporting surface loads to the solid solver " << endl;
< 
3537,3540c2611,2612
<   // Original
<   //vectorField foamSurfaceTraction = -rhoFluid.value()*nu.value()*
<   //  U.boundaryField()[fluidPatchID].snGrad();
<   // Original end
---
>   vectorField foamSurfaceTraction = -rhoFluid.value()*nu.value()*
>     U.boundaryField()[fluidPatchID].snGrad();
3542,3568c2614,2617
<   // Masoud change: based on following taken from StepFoam() 
<           //     vectorField fluidPatchTraction =
<           //        -rhoFluid.value()*nu.value()
<           //        *U.boundaryField()[fluidPatchID].snGrad()
<           //       + rhoFluid.value()*p.boundaryField()[fluidPatchID]
<           //        *fluidsMesh.boundary()[fluidPatchID].nf();
< 
<   dynamicFvMesh &fluidsMesh(this->FluidMesh());
<   vectorField foamSurfaceTraction = -rhoFluid.value()*nu.value()
<       *U.boundaryField()[fluidPatchID].snGrad()
<       + rhoFluid.value()*p.boundaryField()[fluidPatchID]
<       *fluidsMesh.boundary()[fluidPatchID].nf();
<   //Masoud: end
<   
<   //Masoud: sending tractions after some initial time
<   if (currTime > -0.1) {
<      for(int i=0; i<numElementsSurface; ++i) {
<        surfaceTraction[3*i] = foamSurfaceTraction[i].x();
<        surfaceTraction[3*i+1] = foamSurfaceTraction[i].y();
<        surfaceTraction[3*i+2] = foamSurfaceTraction[i].z();
<      }
<   } else {
<      for(int i=0; i<numElementsSurface; ++i) {
<        surfaceTraction[3*i] = 0.0;
<        surfaceTraction[3*i+1] = 0.0;
<        surfaceTraction[3*i+2] = 0.0;
<      }
---
>   for(int i=0; i<numElementsSurface; ++i) {
>     surfaceTraction[3*i] = foamSurfaceTraction[i].x();
>     surfaceTraction[3*i+1] = foamSurfaceTraction[i].y();
>     surfaceTraction[3*i+2] = foamSurfaceTraction[i].z();
3570d2618
<   //Masoud: end
diff -r /Projects/IR/Users/msafdari/sourceCodes/ElmerFoamFSI/Third_Party_Modules/OpenFoamFSI/trunk/native/fsiFOAM.H native/fsiFOAM.H
201,202d200
<   int StepFluidNonItr();
<   int StepFluidItr();
