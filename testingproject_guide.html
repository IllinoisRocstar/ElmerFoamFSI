<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>ElmerFoamFSI: How To Set Up Testing for an IR Project</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IRTriangles_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">ElmerFoamFSI
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">ElmerFoamFSI is fluid-solid interaction simulation application built up from OpenFOAM CFD and Elmer CSM coupled through the IMPACT multiphysics software integration infrastructure.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('testingproject_guide.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">How To Set Up Testing for an IR Project </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="testing_intro"></a>
Introduction</h1>
<p>Testing is part of the IR development process. It is very important that we have a consistent, integrated testing in our codes. General guidelines:</p>
<ul>
<li>We use CMake/CTest/CDash for our test driving substrate</li>
<li>Project unit testing should be centralized/encapsulated in a few constructs</li>
<li>All applications should return 0 to indicate no errors, or passed test, and non-zero otherwise.</li>
<li>Project tests should be integrated through CMake so that the user can use "make test" to run them</li>
</ul>
<h1><a class="anchor" id="testing_constructs_sec"></a>
Testing with IRAD</h1>
<p>IRAD offers facilities designed to assist with code and program testing. IRAD's testing framework supports serial, and parallel tests, platform specific tests, and complex behavior tests. IRAD's testing facilities come in the form of coding constructs and utility programs. Both are described below. </p>
<h2><a class="anchor" id="irad_testing_code"></a>
IRAD Testing Constructs</h2>
<p>IRAD offers the following code constructs for implementing testing in project codes:</p>
<ul>
<li>IRAD::Util::TestResults</li>
<li>IRAD::Util::TestingObject</li>
</ul>
<p>In general, project-specific testing objects can inherit from the IRAD::Util::TestingObject and implement their own tests as member functions of this derived class. The member methods take an object of type IRAD::Util::TestResults (or one that inherits from this class), and populate it with testing results. The results object can be streamed - and so typically these results can be streamed to the screen, to a file, or string for further processing.</p>
<p>The IRAD testing code constructs are defined in <code>IRAD/include/Testing.H</code> and an example of their use can be found in the IRAD::Util::TestObject class. This object implements all the tests for the IRAD::Util namespace, and is driven by the IRAD::Util::UtilTest function. In other words, the IRAD::Util::UtilTest function implements a command line interface for the IRAD::Util::TestObject, which implements all the existing tests for the IRAD::Util namespace.</p>
<p>More extensive use of the IRAD code constructs for testing can be found in the example testing objects for ElmerModuleDriver, which are implemented in <a class="el" href="classElmerModuleDriver_1_1TestingObject.html" title="Project-specific testing object. ">ElmerModuleDriver::TestingObject</a> and ElmerModuleDriver::ParallelTestingObject. These testing objects use simple test fixture functions from the <a class="el" href="namespaceElmerModuleDriver_1_1TestFixture.html" title="Namespace for storing simple test utility fixtures. ">ElmerModuleDriver::TestFixture</a> namespace and are driven by <a class="el" href="namespaceElmerModuleDriver_a657930328d3dc159ded2e9fd6473b2b6.html#a657930328d3dc159ded2e9fd6473b2b6" title="Drives the ElmerModuleDriver::TestObject. ">ElmerModuleDriver::Test</a> and <a class="el" href="namespaceElmerModuleDriver_a81f0cdc909567e8d6ef1546887dfa3e2.html#a81f0cdc909567e8d6ef1546887dfa3e2" title="Drives the ElmerModuleDriver::TestObject. ">ElmerModuleDriver::ParallelTest</a>, respectively.</p>
<dl class="section note"><dt>Note</dt><dd>A major advantage of encapsulating all tests in a single object is that external entities need only to instantiate your project-specific testing object to get access to the project's tests. This greatly reduces the complexity of rolling integrated software products out of code from multiple projects.</dd></dl>
<h2><a class="anchor" id="irad_testing_util"></a>
IRAD Testing Support Utilities</h2>
<p>IRAD also offers a couple of utilities to support the running of tests. These utilities and their documentation are:</p>
<ul>
<li><em>runtest</em> (IRAD::RunTest)</li>
<li><em>testresults</em> (IRAD::TestResults)</li>
</ul>
<h3>Running complex tests with <em>runtest</em>.</h3>
<p>The <em>runtest</em> utility is designed to be called from the project's CMakeLists.txt cmake configuration file. Its purpose is to run scripted tests where the complexity or platform-dependent nature of the test being run precludes its being run as a simple test. The <em>runtest</em> utility can run a single named executable, a list of test from file, or resolve platform-specific tests.</p>
<p>Examples of how to use the <em>runtest</em> utility can be found in <code>ElmerModuleDriver/CMakeLists.txt</code>, where it is used to run the parallel tests (which must use platform-specific parallel job spawning mechanisms), and other platform-specific, or complex behavior tests.</p>
<h3>Checking test results with <em>testresults</em>.</h3>
<p>The <em>testresults</em> utility is designed to extract a particular test result from a test results file with one test result per line. If the test's results are such that it has passed, then <em>testresults</em> returns with a zero exit code, and exits with a non-zero error code otherwise.</p>
<p>Examples of how to use the <em>testresults</em> utility can be found in <code>ElmerModuleDriver/CMakeLists.txt</code>, where it is used to extract the results of all the tests.</p>
<h2><a class="anchor" id="putting_it_together"></a>
Putting it all together</h2>
<p>All together, the IRAD testing facilities provide an end-to-end framework for running, collecting, and reporting your project's tests and results to CMake in such a way that CMake's integrated testing facilty, CTest, can be leveraged to integrate the tests into the project's build system, automate the tests, and report the test results to a <em>testing</em> dashboard. The testing dashboard is a web-based facility which collects and reports test results the test histories. Illinois Rocstar uses CDash for its testing dashboard.</p>
<p>The birds-eye view of the process for using IRAD's testing facilities with CMake/CTest goes like this:</p>
<ol type="1">
<li>Create a project-native testing object (PNTO) by inheriting from IRAD::Util::TestingObject.</li>
<li>Implement unit tests as member functions of the PNTO</li>
<li>Write a driver (or a set of drivers) that instantiates your testing object(s), and drives them to produce a IRAD::Util::TestResults object with the restults from the testing.</li>
<li>INCLUDE(CTEST) in your CMakeLists.txt file.</li>
<li>Invoke the test driver(s) with CMake's ADD_TEST() construct and store the results in a composite testing results file. If necessary use <em>runtest</em> to invoke the actual test(s).</li>
<li>If necessary, use <em>testresults</em> to extract the results of the tests from the composite testing results file and exit with a 0 return code for tests that pass, and a non-zero otherwise. This step is also accomplished with CMake's ADD_TEST().</li>
<li>Configure your project (i.e. run cmake), and then run the integrated tests with "make test".</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>The reason it may or may not be necessary to use <em>runtest</em> and <em>testresults</em> in steps (5) and (6) is that your tests may be directly invoked by CMake's ADD_TEST <b>if</b> the test is a standalone executable that returns 0 if it succeeds, and non-zero otherwise.</dd></dl>
<h1><a class="anchor" id="irpt_testing"></a>
Testing in the Illinois Rocstar Project Template</h1>
<p>Direct examples of using IRAD Testing for several different kinds of tests are provided in the Illinois Rocstar Project Template. The following sections summarize the main gist of each of these examples.</p>
<h2><a class="anchor" id="irpt_serial_tests"></a>
Serial Test Examples</h2>
<p>The Illinois Rocstar Project Template has both a standalone serial program example, and several serial unit tests. The unit testing is described below, and discussion of the standalone test is deferred to a later section.</p>
<p>For the serial unit tests, the PNTO is called <a class="el" href="classElmerModuleDriver_1_1TestingObject.html" title="Project-specific testing object. ">ElmerModuleDriver::TestingObject</a>. This object inherits from IRAD::Util::TestingObject as described in Step (1) above. The unit tests are in the <a class="el" href="classElmerModuleDriver_1_1TestingObject.html" title="Project-specific testing object. ">ElmerModuleDriver::TestingObject</a>'s member methods as prescribed in Step (2). The simple tests and the code construct that they test are:</p>
<ul>
<li><a class="el" href="classElmerModuleDriver_1_1TestingObject_a14258b94075936cb7bfadbcfc9a37b87.html#a14258b94075936cb7bfadbcfc9a37b87" title="Test for ElmerModuleDriver::ExampleFunction. ">ElmerModuleDriver::TestingObject::Test__ExampleFunction</a> tests <a class="el" href="namespaceElmerModuleDriver_a4cc78661909b0a33b6b886a4d4290997.html#a4cc78661909b0a33b6b886a4d4290997" title="Example function for ElmerModuleDriver (this is a brief description). ">ElmerModuleDriver::ExampleFunction</a></li>
<li><a class="el" href="classElmerModuleDriver_1_1TestingObject_a7928083cb5586c2b361e1d29a8dc2b54.html#a7928083cb5586c2b361e1d29a8dc2b54" title="Test for ElmerModuleDriver::TrapezoidQuadrature. ">ElmerModuleDriver::TestingObject::Test__TrapezoidQuadrature</a> tests <a class="el" href="namespaceElmerModuleDriver_a7ea1066c129172a0edf5647d8254e957.html#a7ea1066c129172a0edf5647d8254e957" title="Integrates f with composite trapezoid rule. ">ElmerModuleDriver::TrapezoidQuadrature</a></li>
<li><a class="el" href="classElmerModuleDriver_1_1TestingObject_a7de28a366b07117111ce7c1e9515a434.html#a7de28a366b07117111ce7c1e9515a434" title="Test for ElmerModuleDriver::MidPointQuadrature. ">ElmerModuleDriver::TestingObject::Test__MidPointQuadrature</a> tests <a class="el" href="namespaceElmerModuleDriver_a94390a668cbb6637ea246c660d00d430.html#a94390a668cbb6637ea246c660d00d430" title="Integrates f with composite midpoint rule. ">ElmerModuleDriver::MidPointQuadrature</a></li>
</ul>
<p>The <em>elmermoduledriver_test</em> command-line driver executable, implemented by the <a class="el" href="namespaceElmerModuleDriver_a657930328d3dc159ded2e9fd6473b2b6.html#a657930328d3dc159ded2e9fd6473b2b6" title="Drives the ElmerModuleDriver::TestObject. ">ElmerModuleDriver::Test</a> function drives the <a class="el" href="classElmerModuleDriver_1_1TestingObject.html" title="Project-specific testing object. ">ElmerModuleDriver::TestingObject</a> by instantiating it, and calling the <a class="el" href="classElmerModuleDriver_1_1TestingObject_af1f07f14b9af7708e4264bb38937eed2.html#af1f07f14b9af7708e4264bb38937eed2" title="Runs a test specified by name. ">ElmerModuleDriver::TestingObject::RunTest</a> (if an explicit test name or list was given) or the <a class="el" href="classElmerModuleDriver_1_1TestingObject_a046f7ab06db0acf616b0d2bf3d3146aa.html#a046f7ab06db0acf616b0d2bf3d3146aa">ElmerModuleDriver::TestingObject::Process</a> method to run all tests. This is Step(3).</p>
<p>Step (4) is trivial, and Step (5) is done with the following line from <code>ElmerModuleDriver/CMakeLists.txt</code>:</p>
<blockquote class="doxtable">
<p>ADD_TEST(RunElmerModuleDriverTests ${EXECUTABLE_OUTPUT_PATH}/elmermoduledriver_test -o elmermoduledriver_testresults.txt)</p>
<p></p>
</blockquote>
<p>This runs all of the <a class="el" href="namespaceElmerModuleDriver.html" title="Project-specific namespace. ">ElmerModuleDriver</a> tests implemented by the <a class="el" href="classElmerModuleDriver_1_1TestingObject.html" title="Project-specific testing object. ">ElmerModuleDriver::TestingObject</a>, and stores the results in the file <code>elmermoduledriver_testresults.txt</code>.</p>
<p>For Step (6), the <em>testresults</em> utility is used to extract the results of each of the tests from <code>elmermoduledriver_testresults.txt</code> with the following lines from <code>ElmerModuleDriver/CMakeLists.txt</code>:</p>
<blockquote class="doxtable">
<p>ADD_TEST(ExampleProgram:Works ${EXECUTABLE_OUTPUT_PATH}/testresults ExampleProgram:Works elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ExampleFunction:Works ${EXECUTABLE_OUTPUT_PATH}/testresults ExampleFunction:Works elmermoduledriver_testresults.txt)<br/>
ADD_TEST(TrapezoidQuadrature:Runs ${EXECUTABLE_OUTPUT_PATH}/testresults TrapezoidQuadrature:Runs elmermoduledriver_testresults.txt)<br/>
ADD_TEST(TrapezoidQuadrature:Accurate ${EXECUTABLE_OUTPUT_PATH}/testresults TrapezoidQuadrature:Accurate elmermoduledriver_testresults.txt)<br/>
ADD_TEST(TrapezoidQuadrature:Order ${EXECUTABLE_OUTPUT_PATH}/testresults TrapezoidQuadrature:Order2 elmermoduledriver_testresults.txt)<br/>
ADD_TEST(MidPointQuadrature:Runs ${EXECUTABLE_OUTPUT_PATH}/testresults MidPointQuadrature:Runs elmermoduledriver_testresults.txt)<br/>
ADD_TEST(MidPointQuadrature:Accurate ${EXECUTABLE_OUTPUT_PATH}/testresults MidPointQuadrature:Accurate elmermoduledriver_testresults.txt)<br/>
ADD_TEST(MidPointQuadrature:Order ${EXECUTABLE_OUTPUT_PATH}/testresults MidPointQuadrature:Order2 elmermoduledriver_testresults.txt)<br/>
 </p>
</blockquote>
<p>In Step (7), users configure <a class="el" href="namespaceElmerModuleDriver.html" title="Project-specific namespace. ">ElmerModuleDriver</a> and invoke "make test" to run the tests and report the results to stdout.</p>
<h2><a class="anchor" id="irpt_parallel_tests"></a>
Parallel Test Examples</h2>
<p>The Illinois Rocstar Project Template has both a standalone parallel application, <em>pepi</em>, and parallel unit tests. The <em>pepi</em> program computes <img class="formulaInl" alt="$\pi$" src="form_28.png"/> in parallel by doing parallel quadrature, and the unit tests test the parallel quadrature facility. Both will be discussed in this section.</p>
<p>In this test, the PNTO is called ElmerModuleDriver::ParallelTestingObject. This object inherits from IRAD::Util::TestingObject as described in Step (1) above. The unit tests are in the ElmerModuleDriver::ParallelTestingObject's member methods as prescribed in Step (2). The simple tests and the code construct that they test are:</p>
<ul>
<li>ElmerModuleDriver::ParallelTestingObject::Test__ParallelTrapezoidQuadrature tests <a class="el" href="namespaceElmerModuleDriver_a7ea1066c129172a0edf5647d8254e957.html#a7ea1066c129172a0edf5647d8254e957" title="Integrates f with composite trapezoid rule. ">ElmerModuleDriver::TrapezoidQuadrature</a> in parallel</li>
<li>ElmerModuleDriver::ParallelTestingObject::Test__ParallelMidPointQuadrature tests <a class="el" href="namespaceElmerModuleDriver_a94390a668cbb6637ea246c660d00d430.html#a94390a668cbb6637ea246c660d00d430" title="Integrates f with composite midpoint rule. ">ElmerModuleDriver::MidPointQuadrature</a> in parallel</li>
</ul>
<p>The <em>elmermoduledriver_parallel_test</em> command-line driver executable, implemented by the <a class="el" href="namespaceElmerModuleDriver_a81f0cdc909567e8d6ef1546887dfa3e2.html#a81f0cdc909567e8d6ef1546887dfa3e2" title="Drives the ElmerModuleDriver::TestObject. ">ElmerModuleDriver::ParallelTest</a> function drives the ElmerModuleDriver::ParallelTestingObject by instantiating it, and calling the ElmerModuleDriver::ParallelTestingObject::RunTest (if an explicit test name or list was given) or the ElmerModuleDriver::ParallelTestingObject::Process method to run all tests. This is Step(3).</p>
<p>Step (4) is trivial, and Step (5) for this example is more complicated than that of the serial case. Since this is a parallel test, it must be spawned in parallel using something like <em>mpiexec</em> or <em>mpirun</em>. The parallel application spawning mechanism is platform-dependent, and even may need to be done through a batch queueing system.</p>
<p>Due to the platform-specific nature of executing parallel applications, Step (5) must be accomplished using the <em>runtest</em> utility. This is done in the following line from <code>ElmerModuleDriver/CMakeLists.txt</code>:</p>
<blockquote class="doxtable">
<p>ADD_TEST(RunParallelPlatformTests ${EXECUTABLE_OUTPUT_PATH}/runtest -p ${PROJECT_SOURCE_DIR}/share/Platforms/parallel_platforms -o elmermoduledriver_testresults.txt)</p>
<p></p>
</blockquote>
<p>This line gives the <code>ElmerModuleDriver/share/Platforms/parallel_platforms</code> file as the <em>platform</em> argument to <em>runtest</em>. The parallel_platforms file is line-based and has the following format on each line: </p>
<blockquote class="doxtable">
<p>&lt;hostname&gt; &lt;path to platform-specific test list&gt;</p>
<p></p>
</blockquote>
<p>If not given on the command line, the <em>runtest</em> utility will determine the hostname and resolve the list of tests from this file. The platform-specific test list should list as many parallel testing scripts as one needs to do on the given platform. For example, see <code>ElmerModuleDriver/share/Platforms/parallel_platforms</code>, and <code>ElmerModuleDriver/share/Platforms/mercury_parallel.list</code>. You will see that the list includes two scripts that invoke the parallel tests:</p>
<ol type="1">
<li>mercury_parallel_test1.csh (runs the parallel unit test driver)</li>
<li>mercury_parallel_test2.csh (runs <em>pepi</em>)</li>
</ol>
<p>On Illinois Rocstar's mercury cluster, these tests must be conducted through the batch system. These testing scripts submit the tests to the batch system and report the results. These results are then fed into the <code>elmermoduledriver_testsresults.txt</code> file.</p>
<p>Essentially, these scripts submit the jobs to mercury's queue, and then wait on the results before returning to the calling utility, <em>runtest</em>. For further details on how they do this, see <code>ElmerModuleDriver/share/Platforms/mercury_parallel_test1.csh</code> and <code>ElmerModuleDriver/share/Platforms/mercury_parallel_test2.csh</code>.</p>
<p>Once the <em>runtest</em> utility has returned, then the <code>elmermoduledriver_testresults.txt</code> file has been updated with the results from the parallel tests, and, just like for the serial test Step (6), the <em>testresults</em> utility is used to extract the results of each of the tests from <code>elmermoduledriver_testresults.txt</code> with the following lines from <code>ElmerModuleDriver/CMakeLists.txt</code>:</p>
<blockquote class="doxtable">
<p>ADD_TEST(ParallelExample:Runs ${EXECUTABLE_OUTPUT_PATH}/testresults PEPI:Runs elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelExample:Works ${EXECUTABLE_OUTPUT_PATH}/testresults PEPI:Works elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelTrapezoidQuadrature:Runs ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelTrapezoidQuadrature:Runs elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelTrapezoidQuadrature:Accurate ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelTrapezoidQuadrature:Accurate elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelTrapezoidQuadrature:Order ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelTrapezoidQuadrature:Order2 elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelTrapezoidQuadrature:WeakScaling ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelTrapezoidQuadrature:WeakScaling elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelTrapezoidQuadrature:StrongScaling ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelTrapezoidQuadrature:StrongScaling elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelMidPointQuadrature:Runs ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelMidPointQuadrature:Runs elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelMidPointQuadrature:Accurate ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelMidPointQuadrature:Accurate elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelMidPointQuadrature:Order ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelMidPointQuadrature:Order2 elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelMidPointQuadrature:WeakScaling ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelMidPointQuadrature:WeakScaling elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelMidPointQuadrature:StrongScaling ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelMidPointQuadrature:StrongScaling elmermoduledriver_testresults.txt)<br/>
 </p>
</blockquote>
<p>In Step (7), users configure <a class="el" href="namespaceElmerModuleDriver.html" title="Project-specific namespace. ">ElmerModuleDriver</a> and invoke "make test" to run the tests and report the results to stdout.</p>
<h2><a class="anchor" id="direct_tests"></a>
Direct Test Example</h2>
<p>The Illinois Rocstar Project Template has one serial example program called <em>sep</em>. The <em>sep</em> program simply copies a file. It is a useful example because it can be directly invoked by CTest since <em>sep</em> returns 0 if it succeeds and 1 if not (e.g. the input file did not exist or something).</p>
<p>The following line from the <code>ElmerModuleDriver/CMakeLists.txt</code> file invokes <em>sep</em> and evaluates whether it succeeded or failed (based solely on its return code):</p>
<blockquote class="doxtable">
<p>ADD_TEST(ExampleProgram:Runs ${EXECUTABLE_OUTPUT_PATH}/sep CMakeCache.txt)</p>
<p></p>
</blockquote>
<dl class="section note"><dt>Note</dt><dd>There is no output file, just a name for the test, and then the command it should run.</dd></dl>
<p>In order to evaluate whether <em>sep</em> actually did what it was told to do, we need a more complicated facility. In fact, this is done with <em>runtest</em> just like above. The following line from <code>ElmerModuleDriver/CMakeLists.txt</code> runs a (number of) script(s) from a list. One of these scripts, namely <code>ElmerModuleDriver/share/Testing/test_scripts/serial_tests.csh</code>, actually runs  and checks to make sure it copies a file correctly:</p>
<blockquote class="doxtable">
<p>ADD_TEST(RunTests ${EXECUTABLE_OUTPUT_PATH}/runtest -l ${PROJECT_SOURCE_DIR}/share/Testing/test_scripts/tests.list -o elmermoduledriver_testresults.txt)</p>
<p></p>
</blockquote>
<h2><a class="anchor" id="direct_use"></a>
Reusing the Examples</h2>
<p>It is highly recommended to simply reuse the testing examples provided in the Illinois Rocstar Project Template when creating your own tests that use this framework.</p>
<p>To reuse the example testing objects, the developer could just remove the existing test functions in the serial testing object <a class="el" href="classElmerModuleDriver_1_1TestingObject.html" title="Project-specific testing object. ">ElmerModuleDriver::TestingObject</a> and the parallel testing object, ElmerModuleDriver::ParallelTestingObject and then implement her own unit tests as member functions of those objects.</p>
<p>The corresponding constructs from the <code>CMakeLists.txt</code> file would need to be removed/added as well - and also the scripts invoking the tests, if necessary. The rest of the framework, including the test object drivers would still be valid and should continue to work without modification.</p>
<h1><a class="anchor" id="autotesting_sec"></a>
Automated Testing</h1>
<p>The Illinois Rocstar Project Template has a couple of utilities designed to assist in understanding and setting up automated testing through <a href="http://www.cmake.org/cmake/help/v2.8.8/ctest.html" title="CTest Manual">CTest</a>. A sort of "quickstart" set of steps for setting up automated testing is as follows:</p>
<ol type="1">
<li>Log in to Illinois Rocstar's <a href="http://irweb/cdash">CDash</a> instance and create a new project for your project (if it does not already exist).</li>
<li>Make a directory from which to run your automated builds and tests (e.g. ~/AutomatedTesting).</li>
<li>Copy <code>ElmerModuleDriver/share/Testing/test_scripts/ctest/{automated_test_script.cmake</code>,run_automated_tests,projects} into your testing directory.</li>
<li>Edit the run_automated_tests script with your customizations.</li>
<li>Edit the projects file to remove the examples and add the projects that you want to test.</li>
<li>Test the setup by executing: <blockquote class="doxtable">
<p><code></code>./run_automated_tests <code></code>./projects Experimental <code>~/AutomatedTesting</code> </p>
<p></p>
</blockquote>
</li>
<li>If everything works OK, then add a cron job to invoke <em>run_automated_tests</em> at your desired intervals and modes.</li>
</ol>
<p>For Step(1), log into <a href="http://irweb/cdash">CDash</a> and follow the steps to create a new project. Add yourself as an author, and anyone else that should know about the status of the automated builds/tests.</p>
<p>Steps(2) and (3) are obvious. In Step(4), pay particular attention to the settings of the shell, and to the two optional environment settings, <code>CMAKE_PREFIX_PATH</code> and <code>PROJECT_CONFIGURE_OPTIONS</code>. These options are passed to CMake when CTest configures your project(s) for automated build and testing.</p>
<p>In Step(5), it should be noted that the projects file is processed line-by-line. Each line should indicate the parameters for a single build and test. The expected format for each functional line of projects file is as follows:</p>
<blockquote class="doxtable">
<p>&lt;Project Name&gt;:&lt;Branch Name&gt;:&lt;Branch Path&gt;</p>
<p></p>
</blockquote>
<p>Based on the line from the projects file, the testing utilities will automatically try to check out the following branch from SVN with the following command:</p>
<blockquote class="doxtable">
<p><code>svn</code> <code>co</code> <code><a href="file:///Projects/IR/SourceRepository/">file:///Projects/IR/SourceRepository/</a>&lt;Project</code> Name&gt;/&lt;Branch Path&gt; <code>&lt;Project</code> Name&gt;_&lt;Branch Name&gt;</p>
<p></p>
</blockquote>
<p>If the &lt;Project Name&gt;_&lt;Branch Name&gt; directory already exists, then CTest will simply update from SVN if there are changes in the repository. On fresh check-outs or updates, CTest will (re)configure and (re)build the project and run the tests.</p>
<p>For Step(6), make sure to replace "~/AutomatedTesting" with the directory that you created in Step(2). The usage for the <em>run_automated_tests</em> utility is as follows:</p>
<blockquote class="doxtable">
<p>run_automated_tests &lt;projects file&gt; &lt;mode&gt; &lt;running directory&gt;</p>
<p></p>
</blockquote>
<p>Valid default modes are <em>Experimental</em>, <em>Nightly</em>, and <em>Continuous</em>. The only real difference between Experimental and Nightly is how they are denoted in CDash. Experimental builds can happen at any time, whereas nightly tests are expected to be, well... nightly. Continuous builds are useful for things such as Test Driven Development. Continuous builds do not require cron jobs - but automatically update and build your project according to an interval that you can specify, say every 2 minutes or every 10 minutes for example.</p>
<p>In Step(7), your cron job will (presumably) invoke the nightly build/tests. Assuming you want to to run nightly build and test every night at midnight, say, then your crontab would be:</p>
<blockquote class="doxtable">
<p>00 00 * * * /home/my/AutomatedTesting/run_automated_tests /home/my/AutomatedTesting/projects Nightly /home/my/AutomatedTesting</p>
<p></p>
</blockquote>
<p>In general, the format for the crontab is: </p>
<blockquote class="doxtable">
<p>MM HH DD NN W Command</p>
<p></p>
</blockquote>
<p>Where MM is the two digit minute, HH the two digit hour (in 24 hour format), DD is date of the month, NN is the month, and W is the day of the week (0-6). "Command" is the command to be executed.</p>
<p>Once you have all of this working, the building and testing can be more easily customized. The <a href="http://www.cmake.org/cmake/help/v2.8.8/ctest.html" title="CTest Manual">CTest Manual</a> is useful in learning about the ways this process can be customized further. Builds and tests can also be customized or made more specific by editing/tweaking the <em>run_automated_tests</em> script and cron job(s).</p>
<h1><a class="anchor" id="testing_intro"></a>
Introduction</h1>
<p>Testing is part of the IR development process. It is very important that we have a consistent, integrated testing in our codes. General guidelines:</p>
<ul>
<li>We use CMake/CTest/CDash for our test driving substrate</li>
<li>Project unit testing should be centralized/encapsulated in a few constructs</li>
<li>All applications should return 0 to indicate no errors, or passed test, and non-zero otherwise.</li>
<li>Project tests should be integrated through CMake so that the user can use "make test" to run them</li>
</ul>
<h1><a class="anchor" id="testing_constructs_sec"></a>
Testing with IRAD</h1>
<p>IRAD offers facilities designed to assist with code and program testing. IRAD's testing framework supports serial, and parallel tests, platform specific tests, and complex behavior tests. IRAD's testing facilities come in the form of coding constructs and utility programs. Both are described below. </p>
<h2><a class="anchor" id="irad_testing_code"></a>
IRAD Testing Constructs</h2>
<p>IRAD offers the following code constructs for implementing testing in project codes:</p>
<ul>
<li>IRAD::Util::TestResults</li>
<li>IRAD::Util::TestingObject</li>
</ul>
<p>In general, project-specific testing objects can inherit from the IRAD::Util::TestingObject and implement their own tests as member functions of this derived class. The member methods take an object of type IRAD::Util::TestResults (or one that inherits from this class), and populate it with testing results. The results object can be streamed - and so typically these results can be streamed to the screen, to a file, or string for further processing.</p>
<p>The IRAD testing code constructs are defined in <code>IRAD/include/Testing.H</code> and an example of their use can be found in the IRAD::Util::TestObject class. This object implements all the tests for the IRAD::Util namespace, and is driven by the IRAD::Util::UtilTest function. In other words, the IRAD::Util::UtilTest function implements a command line interface for the IRAD::Util::TestObject, which implements all the existing tests for the IRAD::Util namespace.</p>
<p>More extensive use of the IRAD code constructs for testing can be found in the example testing objects for OpenFoamModuleDriver, which are implemented in <a class="el" href="classOpenFoamModuleDriver_1_1TestingObject.html" title="Project-specific testing object. ">OpenFoamModuleDriver::TestingObject</a> and OpenFoamModuleDriver::ParallelTestingObject. These testing objects use simple test fixture functions from the <a class="el" href="namespaceOpenFoamModuleDriver_1_1TestFixture.html" title="Namespace for storing simple test utility fixtures. ">OpenFoamModuleDriver::TestFixture</a> namespace and are driven by <a class="el" href="namespaceOpenFoamModuleDriver_a98bd69551725493def1a31bfe72b0781.html#a98bd69551725493def1a31bfe72b0781" title="Drives the OpenFoamModuleDriver::TestObject. ">OpenFoamModuleDriver::Test</a> and <a class="el" href="namespaceOpenFoamModuleDriver_a2dc08fd0ec5c64aa9b09d8bb8b65f88e.html#a2dc08fd0ec5c64aa9b09d8bb8b65f88e" title="Drives the OpenFoamModuleDriver::TestObject. ">OpenFoamModuleDriver::ParallelTest</a>, respectively.</p>
<dl class="section note"><dt>Note</dt><dd>A major advantage of encapsulating all tests in a single object is that external entities need only to instantiate your project-specific testing object to get access to the project's tests. This greatly reduces the complexity of rolling integrated software products out of code from multiple projects.</dd></dl>
<h2><a class="anchor" id="irad_testing_util"></a>
IRAD Testing Support Utilities</h2>
<p>IRAD also offers a couple of utilities to support the running of tests. These utilities and their documentation are:</p>
<ul>
<li><em>runtest</em> (IRAD::RunTest)</li>
<li><em>testresults</em> (IRAD::TestResults)</li>
</ul>
<h3>Running complex tests with <em>runtest</em>.</h3>
<p>The <em>runtest</em> utility is designed to be called from the project's CMakeLists.txt cmake configuration file. Its purpose is to run scripted tests where the complexity or platform-dependent nature of the test being run precludes its being run as a simple test. The <em>runtest</em> utility can run a single named executable, a list of test from file, or resolve platform-specific tests.</p>
<p>Examples of how to use the <em>runtest</em> utility can be found in <code>OpenFoamModuleDriver/CMakeLists.txt</code>, where it is used to run the parallel tests (which must use platform-specific parallel job spawning mechanisms), and other platform-specific, or complex behavior tests.</p>
<h3>Checking test results with <em>testresults</em>.</h3>
<p>The <em>testresults</em> utility is designed to extract a particular test result from a test results file with one test result per line. If the test's results are such that it has passed, then <em>testresults</em> returns with a zero exit code, and exits with a non-zero error code otherwise.</p>
<p>Examples of how to use the <em>testresults</em> utility can be found in <code>OpenFoamModuleDriver/CMakeLists.txt</code>, where it is used to extract the results of all the tests.</p>
<h2><a class="anchor" id="putting_it_together"></a>
Putting it all together</h2>
<p>All together, the IRAD testing facilities provide an end-to-end framework for running, collecting, and reporting your project's tests and results to CMake in such a way that CMake's integrated testing facilty, CTest, can be leveraged to integrate the tests into the project's build system, automate the tests, and report the test results to a <em>testing</em> dashboard. The testing dashboard is a web-based facility which collects and reports test results the test histories. Illinois Rocstar uses CDash for its testing dashboard.</p>
<p>The birds-eye view of the process for using IRAD's testing facilities with CMake/CTest goes like this:</p>
<ol type="1">
<li>Create a project-native testing object (PNTO) by inheriting from IRAD::Util::TestingObject.</li>
<li>Implement unit tests as member functions of the PNTO</li>
<li>Write a driver (or a set of drivers) that instantiates your testing object(s), and drives them to produce a IRAD::Util::TestResults object with the restults from the testing.</li>
<li>INCLUDE(CTEST) in your CMakeLists.txt file.</li>
<li>Invoke the test driver(s) with CMake's ADD_TEST() construct and store the results in a composite testing results file. If necessary use <em>runtest</em> to invoke the actual test(s).</li>
<li>If necessary, use <em>testresults</em> to extract the results of the tests from the composite testing results file and exit with a 0 return code for tests that pass, and a non-zero otherwise. This step is also accomplished with CMake's ADD_TEST().</li>
<li>Configure your project (i.e. run cmake), and then run the integrated tests with "make test".</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>The reason it may or may not be necessary to use <em>runtest</em> and <em>testresults</em> in steps (5) and (6) is that your tests may be directly invoked by CMake's ADD_TEST <b>if</b> the test is a standalone executable that returns 0 if it succeeds, and non-zero otherwise.</dd></dl>
<h1><a class="anchor" id="irpt_testing"></a>
Testing in the Illinois Rocstar Project Template</h1>
<p>Direct examples of using IRAD Testing for several different kinds of tests are provided in the Illinois Rocstar Project Template. The following sections summarize the main gist of each of these examples.</p>
<h2><a class="anchor" id="irpt_serial_tests"></a>
Serial Test Examples</h2>
<p>The Illinois Rocstar Project Template has both a standalone serial program example, and several serial unit tests. The unit testing is described below, and discussion of the standalone test is deferred to a later section.</p>
<p>For the serial unit tests, the PNTO is called <a class="el" href="classOpenFoamModuleDriver_1_1TestingObject.html" title="Project-specific testing object. ">OpenFoamModuleDriver::TestingObject</a>. This object inherits from IRAD::Util::TestingObject as described in Step (1) above. The unit tests are in the <a class="el" href="classOpenFoamModuleDriver_1_1TestingObject.html" title="Project-specific testing object. ">OpenFoamModuleDriver::TestingObject</a>'s member methods as prescribed in Step (2). The simple tests and the code construct that they test are:</p>
<ul>
<li>OpenFoamModuleDriver::TestingObject::Test__ExampleFunction tests OpenFoamModuleDriver::ExampleFunction</li>
<li>OpenFoamModuleDriver::TestingObject::Test__TrapezoidQuadrature tests OpenFoamModuleDriver::TrapezoidQuadrature</li>
<li>OpenFoamModuleDriver::TestingObject::Test__MidPointQuadrature tests OpenFoamModuleDriver::MidPointQuadrature</li>
</ul>
<p>The <em>elmermoduledriver_test</em> command-line driver executable, implemented by the <a class="el" href="namespaceOpenFoamModuleDriver_a98bd69551725493def1a31bfe72b0781.html#a98bd69551725493def1a31bfe72b0781" title="Drives the OpenFoamModuleDriver::TestObject. ">OpenFoamModuleDriver::Test</a> function drives the <a class="el" href="classOpenFoamModuleDriver_1_1TestingObject.html" title="Project-specific testing object. ">OpenFoamModuleDriver::TestingObject</a> by instantiating it, and calling the <a class="el" href="classOpenFoamModuleDriver_1_1TestingObject_af1f07f14b9af7708e4264bb38937eed2.html#af1f07f14b9af7708e4264bb38937eed2" title="Runs a test specified by name. ">OpenFoamModuleDriver::TestingObject::RunTest</a> (if an explicit test name or list was given) or the <a class="el" href="classOpenFoamModuleDriver_1_1TestingObject_a046f7ab06db0acf616b0d2bf3d3146aa.html#a046f7ab06db0acf616b0d2bf3d3146aa">OpenFoamModuleDriver::TestingObject::Process</a> method to run all tests. This is Step(3).</p>
<p>Step (4) is trivial, and Step (5) is done with the following line from <code>OpenFoamModuleDriver/CMakeLists.txt</code>:</p>
<blockquote class="doxtable">
<p>ADD_TEST(RunOpenFoamModuleDriverTests ${EXECUTABLE_OUTPUT_PATH}/elmermoduledriver_test -o elmermoduledriver_testresults.txt)</p>
<p></p>
</blockquote>
<p>This runs all of the <a class="el" href="namespaceOpenFoamModuleDriver.html" title="Project-specific namespace. ">OpenFoamModuleDriver</a> tests implemented by the <a class="el" href="classOpenFoamModuleDriver_1_1TestingObject.html" title="Project-specific testing object. ">OpenFoamModuleDriver::TestingObject</a>, and stores the results in the file <code>elmermoduledriver_testresults.txt</code>.</p>
<p>For Step (6), the <em>testresults</em> utility is used to extract the results of each of the tests from <code>elmermoduledriver_testresults.txt</code> with the following lines from <code>OpenFoamModuleDriver/CMakeLists.txt</code>:</p>
<blockquote class="doxtable">
<p>ADD_TEST(ExampleProgram:Works ${EXECUTABLE_OUTPUT_PATH}/testresults ExampleProgram:Works elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ExampleFunction:Works ${EXECUTABLE_OUTPUT_PATH}/testresults ExampleFunction:Works elmermoduledriver_testresults.txt)<br/>
ADD_TEST(TrapezoidQuadrature:Runs ${EXECUTABLE_OUTPUT_PATH}/testresults TrapezoidQuadrature:Runs elmermoduledriver_testresults.txt)<br/>
ADD_TEST(TrapezoidQuadrature:Accurate ${EXECUTABLE_OUTPUT_PATH}/testresults TrapezoidQuadrature:Accurate elmermoduledriver_testresults.txt)<br/>
ADD_TEST(TrapezoidQuadrature:Order ${EXECUTABLE_OUTPUT_PATH}/testresults TrapezoidQuadrature:Order2 elmermoduledriver_testresults.txt)<br/>
ADD_TEST(MidPointQuadrature:Runs ${EXECUTABLE_OUTPUT_PATH}/testresults MidPointQuadrature:Runs elmermoduledriver_testresults.txt)<br/>
ADD_TEST(MidPointQuadrature:Accurate ${EXECUTABLE_OUTPUT_PATH}/testresults MidPointQuadrature:Accurate elmermoduledriver_testresults.txt)<br/>
ADD_TEST(MidPointQuadrature:Order ${EXECUTABLE_OUTPUT_PATH}/testresults MidPointQuadrature:Order2 elmermoduledriver_testresults.txt)<br/>
 </p>
</blockquote>
<p>In Step (7), users configure <a class="el" href="namespaceOpenFoamModuleDriver.html" title="Project-specific namespace. ">OpenFoamModuleDriver</a> and invoke "make test" to run the tests and report the results to stdout.</p>
<h2><a class="anchor" id="irpt_parallel_tests"></a>
Parallel Test Examples</h2>
<p>The Illinois Rocstar Project Template has both a standalone parallel application, <em>pepi</em>, and parallel unit tests. The <em>pepi</em> program computes <img class="formulaInl" alt="$\pi$" src="form_28.png"/> in parallel by doing parallel quadrature, and the unit tests test the parallel quadrature facility. Both will be discussed in this section.</p>
<p>In this test, the PNTO is called OpenFoamModuleDriver::ParallelTestingObject. This object inherits from IRAD::Util::TestingObject as described in Step (1) above. The unit tests are in the OpenFoamModuleDriver::ParallelTestingObject's member methods as prescribed in Step (2). The simple tests and the code construct that they test are:</p>
<ul>
<li>OpenFoamModuleDriver::ParallelTestingObject::Test__ParallelTrapezoidQuadrature tests OpenFoamModuleDriver::TrapezoidQuadrature in parallel</li>
<li>OpenFoamModuleDriver::ParallelTestingObject::Test__ParallelMidPointQuadrature tests OpenFoamModuleDriver::MidPointQuadrature in parallel</li>
</ul>
<p>The <em>elmermoduledriver_parallel_test</em> command-line driver executable, implemented by the <a class="el" href="namespaceOpenFoamModuleDriver_a2dc08fd0ec5c64aa9b09d8bb8b65f88e.html#a2dc08fd0ec5c64aa9b09d8bb8b65f88e" title="Drives the OpenFoamModuleDriver::TestObject. ">OpenFoamModuleDriver::ParallelTest</a> function drives the OpenFoamModuleDriver::ParallelTestingObject by instantiating it, and calling the OpenFoamModuleDriver::ParallelTestingObject::RunTest (if an explicit test name or list was given) or the OpenFoamModuleDriver::ParallelTestingObject::Process method to run all tests. This is Step(3).</p>
<p>Step (4) is trivial, and Step (5) for this example is more complicated than that of the serial case. Since this is a parallel test, it must be spawned in parallel using something like <em>mpiexec</em> or <em>mpirun</em>. The parallel application spawning mechanism is platform-dependent, and even may need to be done through a batch queueing system.</p>
<p>Due to the platform-specific nature of executing parallel applications, Step (5) must be accomplished using the <em>runtest</em> utility. This is done in the following line from <code>OpenFoamModuleDriver/CMakeLists.txt</code>:</p>
<blockquote class="doxtable">
<p>ADD_TEST(RunParallelPlatformTests ${EXECUTABLE_OUTPUT_PATH}/runtest -p ${PROJECT_SOURCE_DIR}/share/Platforms/parallel_platforms -o elmermoduledriver_testresults.txt)</p>
<p></p>
</blockquote>
<p>This line gives the <code>OpenFoamModuleDriver/share/Platforms/parallel_platforms</code> file as the <em>platform</em> argument to <em>runtest</em>. The parallel_platforms file is line-based and has the following format on each line: </p>
<blockquote class="doxtable">
<p>&lt;hostname&gt; &lt;path to platform-specific test list&gt;</p>
<p></p>
</blockquote>
<p>If not given on the command line, the <em>runtest</em> utility will determine the hostname and resolve the list of tests from this file. The platform-specific test list should list as many parallel testing scripts as one needs to do on the given platform. For example, see <code>OpenFoamModuleDriver/share/Platforms/parallel_platforms</code>, and <code>OpenFoamModuleDriver/share/Platforms/mercury_parallel.list</code>. You will see that the list includes two scripts that invoke the parallel tests:</p>
<ol type="1">
<li>mercury_parallel_test1.csh (runs the parallel unit test driver)</li>
<li>mercury_parallel_test2.csh (runs <em>pepi</em>)</li>
</ol>
<p>On Illinois Rocstar's mercury cluster, these tests must be conducted through the batch system. These testing scripts submit the tests to the batch system and report the results. These results are then fed into the <code>elmermoduledriver_testsresults.txt</code> file.</p>
<p>Essentially, these scripts submit the jobs to mercury's queue, and then wait on the results before returning to the calling utility, <em>runtest</em>. For further details on how they do this, see <code>OpenFoamModuleDriver/share/Platforms/mercury_parallel_test1.csh</code> and <code>OpenFoamModuleDriver/share/Platforms/mercury_parallel_test2.csh</code>.</p>
<p>Once the <em>runtest</em> utility has returned, then the <code>elmermoduledriver_testresults.txt</code> file has been updated with the results from the parallel tests, and, just like for the serial test Step (6), the <em>testresults</em> utility is used to extract the results of each of the tests from <code>elmermoduledriver_testresults.txt</code> with the following lines from <code>OpenFoamModuleDriver/CMakeLists.txt</code>:</p>
<blockquote class="doxtable">
<p>ADD_TEST(ParallelExample:Runs ${EXECUTABLE_OUTPUT_PATH}/testresults PEPI:Runs elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelExample:Works ${EXECUTABLE_OUTPUT_PATH}/testresults PEPI:Works elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelTrapezoidQuadrature:Runs ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelTrapezoidQuadrature:Runs elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelTrapezoidQuadrature:Accurate ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelTrapezoidQuadrature:Accurate elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelTrapezoidQuadrature:Order ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelTrapezoidQuadrature:Order2 elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelTrapezoidQuadrature:WeakScaling ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelTrapezoidQuadrature:WeakScaling elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelTrapezoidQuadrature:StrongScaling ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelTrapezoidQuadrature:StrongScaling elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelMidPointQuadrature:Runs ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelMidPointQuadrature:Runs elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelMidPointQuadrature:Accurate ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelMidPointQuadrature:Accurate elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelMidPointQuadrature:Order ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelMidPointQuadrature:Order2 elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelMidPointQuadrature:WeakScaling ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelMidPointQuadrature:WeakScaling elmermoduledriver_testresults.txt)<br/>
ADD_TEST(ParallelMidPointQuadrature:StrongScaling ${EXECUTABLE_OUTPUT_PATH}/testresults ParallelMidPointQuadrature:StrongScaling elmermoduledriver_testresults.txt)<br/>
 </p>
</blockquote>
<p>In Step (7), users configure <a class="el" href="namespaceOpenFoamModuleDriver.html" title="Project-specific namespace. ">OpenFoamModuleDriver</a> and invoke "make test" to run the tests and report the results to stdout.</p>
<h2><a class="anchor" id="direct_tests"></a>
Direct Test Example</h2>
<p>The Illinois Rocstar Project Template has one serial example program called <em>sep</em>. The <em>sep</em> program simply copies a file. It is a useful example because it can be directly invoked by CTest since <em>sep</em> returns 0 if it succeeds and 1 if not (e.g. the input file did not exist or something).</p>
<p>The following line from the <code>OpenFoamModuleDriver/CMakeLists.txt</code> file invokes <em>sep</em> and evaluates whether it succeeded or failed (based solely on its return code):</p>
<blockquote class="doxtable">
<p>ADD_TEST(ExampleProgram:Runs ${EXECUTABLE_OUTPUT_PATH}/sep CMakeCache.txt)</p>
<p></p>
</blockquote>
<dl class="section note"><dt>Note</dt><dd>There is no output file, just a name for the test, and then the command it should run.</dd></dl>
<p>In order to evaluate whether <em>sep</em> actually did what it was told to do, we need a more complicated facility. In fact, this is done with <em>runtest</em> just like above. The following line from <code>OpenFoamModuleDriver/CMakeLists.txt</code> runs a (number of) script(s) from a list. One of these scripts, namely <code>OpenFoamModuleDriver/share/Testing/test_scripts/serial_tests.csh</code>, actually runs  and checks to make sure it copies a file correctly:</p>
<blockquote class="doxtable">
<p>ADD_TEST(RunTests ${EXECUTABLE_OUTPUT_PATH}/runtest -l ${PROJECT_SOURCE_DIR}/share/Testing/test_scripts/tests.list -o elmermoduledriver_testresults.txt)</p>
<p></p>
</blockquote>
<h2><a class="anchor" id="direct_use"></a>
Reusing the Examples</h2>
<p>It is highly recommended to simply reuse the testing examples provided in the Illinois Rocstar Project Template when creating your own tests that use this framework.</p>
<p>To reuse the example testing objects, the developer could just remove the existing test functions in the serial testing object <a class="el" href="classOpenFoamModuleDriver_1_1TestingObject.html" title="Project-specific testing object. ">OpenFoamModuleDriver::TestingObject</a> and the parallel testing object, OpenFoamModuleDriver::ParallelTestingObject and then implement her own unit tests as member functions of those objects.</p>
<p>The corresponding constructs from the <code>CMakeLists.txt</code> file would need to be removed/added as well - and also the scripts invoking the tests, if necessary. The rest of the framework, including the test object drivers would still be valid and should continue to work without modification.</p>
<h1><a class="anchor" id="autotesting_sec"></a>
Automated Testing</h1>
<p>The Illinois Rocstar Project Template has a couple of utilities designed to assist in understanding and setting up automated testing through <a href="http://www.cmake.org/cmake/help/v2.8.8/ctest.html" title="CTest Manual">CTest</a>. A sort of "quickstart" set of steps for setting up automated testing is as follows:</p>
<ol type="1">
<li>Log in to Illinois Rocstar's <a href="http://irweb/cdash">CDash</a> instance and create a new project for your project (if it does not already exist).</li>
<li>Make a directory from which to run your automated builds and tests (e.g. ~/AutomatedTesting).</li>
<li>Copy <code>OpenFoamModuleDriver/share/Testing/test_scripts/ctest/{automated_test_script.cmake</code>,run_automated_tests,projects} into your testing directory.</li>
<li>Edit the run_automated_tests script with your customizations.</li>
<li>Edit the projects file to remove the examples and add the projects that you want to test.</li>
<li>Test the setup by executing: <blockquote class="doxtable">
<p><code></code>./run_automated_tests <code></code>./projects Experimental <code>~/AutomatedTesting</code> </p>
<p></p>
</blockquote>
</li>
<li>If everything works OK, then add a cron job to invoke <em>run_automated_tests</em> at your desired intervals and modes.</li>
</ol>
<p>For Step(1), log into <a href="http://irweb/cdash">CDash</a> and follow the steps to create a new project. Add yourself as an author, and anyone else that should know about the status of the automated builds/tests.</p>
<p>Steps(2) and (3) are obvious. In Step(4), pay particular attention to the settings of the shell, and to the two optional environment settings, <code>CMAKE_PREFIX_PATH</code> and <code>PROJECT_CONFIGURE_OPTIONS</code>. These options are passed to CMake when CTest configures your project(s) for automated build and testing.</p>
<p>In Step(5), it should be noted that the projects file is processed line-by-line. Each line should indicate the parameters for a single build and test. The expected format for each functional line of projects file is as follows:</p>
<blockquote class="doxtable">
<p>&lt;Project Name&gt;:&lt;Branch Name&gt;:&lt;Branch Path&gt;</p>
<p></p>
</blockquote>
<p>Based on the line from the projects file, the testing utilities will automatically try to check out the following branch from SVN with the following command:</p>
<blockquote class="doxtable">
<p><code>svn</code> <code>co</code> <code><a href="file:///Projects/IR/SourceRepository/">file:///Projects/IR/SourceRepository/</a>&lt;Project</code> Name&gt;/&lt;Branch Path&gt; <code>&lt;Project</code> Name&gt;_&lt;Branch Name&gt;</p>
<p></p>
</blockquote>
<p>If the &lt;Project Name&gt;_&lt;Branch Name&gt; directory already exists, then CTest will simply update from SVN if there are changes in the repository. On fresh check-outs or updates, CTest will (re)configure and (re)build the project and run the tests.</p>
<p>For Step(6), make sure to replace "~/AutomatedTesting" with the directory that you created in Step(2). The usage for the <em>run_automated_tests</em> utility is as follows:</p>
<blockquote class="doxtable">
<p>run_automated_tests &lt;projects file&gt; &lt;mode&gt; &lt;running directory&gt;</p>
<p></p>
</blockquote>
<p>Valid default modes are <em>Experimental</em>, <em>Nightly</em>, and <em>Continuous</em>. The only real difference between Experimental and Nightly is how they are denoted in CDash. Experimental builds can happen at any time, whereas nightly tests are expected to be, well... nightly. Continuous builds are useful for things such as Test Driven Development. Continuous builds do not require cron jobs - but automatically update and build your project according to an interval that you can specify, say every 2 minutes or every 10 minutes for example.</p>
<p>In Step(7), your cron job will (presumably) invoke the nightly build/tests. Assuming you want to to run nightly build and test every night at midnight, say, then your crontab would be:</p>
<blockquote class="doxtable">
<p>00 00 * * * /home/my/AutomatedTesting/run_automated_tests /home/my/AutomatedTesting/projects Nightly /home/my/AutomatedTesting</p>
<p></p>
</blockquote>
<p>In general, the format for the crontab is: </p>
<blockquote class="doxtable">
<p>MM HH DD NN W Command</p>
<p></p>
</blockquote>
<p>Where MM is the two digit minute, HH the two digit hour (in 24 hour format), DD is date of the month, NN is the month, and W is the day of the week (0-6). "Command" is the command to be executed.</p>
<p>Once you have all of this working, the building and testing can be more easily customized. The <a href="http://www.cmake.org/cmake/help/v2.8.8/ctest.html" title="CTest Manual">CTest Manual</a> is useful in learning about the ways this process can be customized further. Builds and tests can also be customized or made more specific by editing/tweaking the <em>run_automated_tests</em> script and cron job(s). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">ElmerFoamFSI Documentation</a></li><li class="navelem"><a class="el" href="group__irp.html">Illinois Rocstar Project Template</a></li>
    <li class="footer">Generated on Mon Jul 25 2016 15:50:54 for ElmerFoamFSI by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
